<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A cross-platform library for opening OS pipes, like those from `pipe` on Linux or `CreatePipe` on Windows. The Rust standard library provides `Stdio::piped` for simple use cases involving child processes, but it doesn’t support creating pipes directly. This crate fills that gap."><meta name="keywords" content="rust, rustlang, rust-lang, os_pipe"><title>os_pipe - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../dark.css" disabled><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script src="../crates.js"></script><script defer src="../main.js"></script>
    <noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a class="sidebar-logo" href="../os_pipe/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.png" alt="logo"></div>
        </a><h2 class="location">Crate os_pipe</h2><div class="block version"><div class="narrow-helper"></div><p>Version 1.0.1</p></div><div class="sidebar-elems"><a id="all-types" href="all.html"><p>See all os_pipe's items</p></a><div class="block items"><ul><li><a href="#structs">Structs</a></li><li><a href="#functions">Functions</a></li></ul></div><div id="sidebar-vars" data-name="os_pipe" data-ty="mod" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../os_pipe/index.html"><img class="rust-logo" src="../rust-logo.png" alt="logo"></a><nav class="sub"><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><h1 class="fqn"><span class="in-band">Crate <a class="mod" href="#">os_pipe</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/os_pipe/lib.rs.html#1-493" title="goto source code">[src]</a></span></h1><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A cross-platform library for opening OS pipes, like those from
<a href="https://man7.org/linux/man-pages/man2/pipe.2.html"><code>pipe</code></a> on Linux
or
<a href="https://docs.microsoft.com/en-us/windows/win32/api/namedpipeapi/nf-namedpipeapi-createpipe"><code>CreatePipe</code></a>
on Windows. The Rust standard library provides
<a href="https://doc.rust-lang.org/std/process/struct.Stdio.html#method.piped"><code>Stdio::piped</code></a>
for simple use cases involving child processes, but it doesn’t
support creating pipes directly. This crate fills that gap.</p>
<ul>
<li><a href="https://docs.rs/os_pipe">Docs</a></li>
<li><a href="https://crates.io/crates/os_pipe">Crate</a></li>
<li><a href="https://github.com/oconnor663/os_pipe.rs">Repo</a></li>
</ul>
<h2 id="common-deadlocks-related-to-pipes" class="section-header"><a href="#common-deadlocks-related-to-pipes">Common deadlocks related to pipes</a></h2>
<p>When you work with pipes, you often end up debugging a deadlock at
some point. These can be confusing if you don’t know why they
happen. Here are two things you need to know:</p>
<ol>
<li>Pipe reads will block waiting for input as long as there’s at
least one writer still open. <strong>If you forget to close a writer,
reads will block forever.</strong> This includes writers that you give
to child processes.</li>
<li>Pipes have an internal buffer of some fixed size. On Linux for
example, pipe buffers are 64 KiB by default. When the buffer is
full, writes will block waiting for space. <strong>If the buffer is
full and there aren’t any readers, writes will block forever.</strong></li>
</ol>
<p>Deadlocks caused by a forgotten writer usually show up immediately,
which makes them relatively easy to fix once you know what to look
for. (See “Avoid a deadlock!” in the example code below.) However,
deadlocks caused by full pipe buffers are trickier. These might only
show up for larger inputs, and they might be timing-dependent or
platform-dependent. If you find that writing to a pipe deadlocks
sometimes, think about who’s supposed to be reading from that pipe,
and whether that thread or process might be blocked on something
else. For more on this, see the <a href="https://github.com/oconnor663/duct.py/blob/master/gotchas.md#using-io-threads-to-avoid-blocking-children">Gotchas
Doc</a>
from the <a href="https://github.com/oconnor663/duct.rs"><code>duct</code></a> crate. (And
consider whether <a href="https://github.com/oconnor663/duct.rs"><code>duct</code></a>
might be a good fit for your use case.)</p>
<h2 id="examples" class="section-header"><a href="#examples">Examples</a></h2>
<p>Here we write a single byte into a pipe and read it back out:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::io::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> (<span class="kw-2">mut</span> <span class="ident">reader</span>, <span class="kw-2">mut</span> <span class="ident">writer</span>) <span class="op">=</span> <span class="ident">os_pipe::pipe</span>()<span class="question-mark">?</span>;
<span class="comment">// XXX: If this write blocks, we&#39;ll never get to the read.</span>
<span class="ident">writer</span>.<span class="ident">write_all</span>(<span class="string">b&quot;x&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">output</span> <span class="op">=</span> [<span class="number">0</span>];
<span class="ident">reader</span>.<span class="ident">read_exact</span>(<span class="kw-2">&amp;mut</span> <span class="ident">output</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="string">b&quot;x&quot;</span>, <span class="kw-2">&amp;</span><span class="ident">output</span>);</code></pre></div>
<p>This is a minimal working example, but as discussed in the section
above, reading and writing on the same thread like this is
deadlock-prone. If we wrote 100 KB instead of just one byte, this
example would block on <code>write_all</code>, it would never make it to
<code>read_exact</code>, and that would be a deadlock. Doing the read and write
from different threads or different processes would fix the
deadlock.</p>
<p>For a more complex example, here we join the stdout and stderr of a
child process into a single pipe. To do that we open a pipe, clone
its writer, and set that pair of writers as the child’s stdout and
stderr. (This is possible because <code>PipeWriter</code> implements
<code>Into&lt;Stdio&gt;</code>.) Then we can read interleaved output from the pipe
reader. This example is deadlock-free, but note the comment about
closing the writers.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// We&#39;re going to spawn a child process that prints &quot;foo&quot; to stdout</span>
<span class="comment">// and &quot;bar&quot; to stderr, and we&#39;ll combine these into a single pipe.</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">command</span> <span class="op">=</span> <span class="ident">std::process::Command::new</span>(<span class="string">&quot;python&quot;</span>);
<span class="ident">command</span>.<span class="ident">args</span>(<span class="kw-2">&amp;</span>[<span class="string">&quot;-c&quot;</span>, <span class="string">r#&quot;
import sys
sys.stdout.write(&quot;foo&quot;)
sys.stdout.flush()
sys.stderr.write(&quot;bar&quot;)
sys.stderr.flush()
&quot;#</span>]);

<span class="comment">// Here&#39;s the interesting part. Open a pipe, clone its writer, and</span>
<span class="comment">// set that pair of writers as the child&#39;s stdout and stderr.</span>
<span class="kw">let</span> (<span class="kw-2">mut</span> <span class="ident">reader</span>, <span class="ident">writer</span>) <span class="op">=</span> <span class="ident">os_pipe::pipe</span>()<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">writer_clone</span> <span class="op">=</span> <span class="ident">writer</span>.<span class="ident">try_clone</span>()<span class="question-mark">?</span>;
<span class="ident">command</span>.<span class="ident">stdout</span>(<span class="ident">writer</span>);
<span class="ident">command</span>.<span class="ident">stderr</span>(<span class="ident">writer_clone</span>);

<span class="comment">// Now start the child process running.</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">handle</span> <span class="op">=</span> <span class="ident">command</span>.<span class="ident">spawn</span>()<span class="question-mark">?</span>;

<span class="comment">// Avoid a deadlock! This parent process is still holding open pipe</span>
<span class="comment">// writers inside the Command object, and we have to close those</span>
<span class="comment">// before we read. Here we do this by dropping the Command object.</span>
<span class="ident">drop</span>(<span class="ident">command</span>);

<span class="comment">// Finally we can read all the output and clean up the child.</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">output</span> <span class="op">=</span> <span class="ident">String::new</span>();
<span class="ident">reader</span>.<span class="ident">read_to_string</span>(<span class="kw-2">&amp;mut</span> <span class="ident">output</span>)<span class="question-mark">?</span>;
<span class="ident">handle</span>.<span class="ident">wait</span>()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="ident">output</span>, <span class="string">&quot;foobar&quot;</span>);</code></pre></div>
<p>Note that the <a href="https://github.com/oconnor663/duct.rs"><code>duct</code></a> crate
can reproduce the example above in a single line of code, with no
risk of deadlocks and no risk of leaking <a href="https://en.wikipedia.org/wiki/Zombie_process">zombie
children</a>.</p>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.PipeReader.html" title="os_pipe::PipeReader struct">PipeReader</a></div><div class="item-right docblock-short"><p>The reading end of a pipe, returned by <a href="fn.pipe.html"><code>pipe</code></a>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.PipeWriter.html" title="os_pipe::PipeWriter struct">PipeWriter</a></div><div class="item-right docblock-short"><p>The writing end of a pipe, returned by <a href="fn.pipe.html"><code>pipe</code></a>.</p>
</div></div></div><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.dup_stderr.html" title="os_pipe::dup_stderr fn">dup_stderr</a></div><div class="item-right docblock-short"><p>Get a duplicated copy of the current process’s standard error, as a
<a href="struct.PipeWriter.html"><code>PipeWriter</code></a>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.dup_stdin.html" title="os_pipe::dup_stdin fn">dup_stdin</a></div><div class="item-right docblock-short"><p>Get a duplicated copy of the current process’s standard input, as a
<a href="struct.PipeReader.html"><code>PipeReader</code></a>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.dup_stdout.html" title="os_pipe::dup_stdout fn">dup_stdout</a></div><div class="item-right docblock-short"><p>Get a duplicated copy of the current process’s standard output, as a
<a href="struct.PipeWriter.html"><code>PipeWriter</code></a>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.pipe.html" title="os_pipe::pipe fn">pipe</a></div><div class="item-right docblock-short"><p>Open a new pipe and return a <a href="struct.PipeReader.html"><code>PipeReader</code></a> and <a href="struct.PipeWriter.html"><code>PipeWriter</code></a> pair.</p>
</div></div></div></section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="os_pipe" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.59.0 (9d1b2106e 2022-02-23)" ></div>
</body></html>