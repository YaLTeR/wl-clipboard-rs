<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A trait for handlers of proxies’ events delivered to an `EventQueue`."><title>Dispatch in wayland_client - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-ac92e1bbe349e143.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="wayland_client" data-themes="" data-resource-suffix="" data-rustdoc-version="1.76.0 (07dca489a 2024-02-04)" data-channel="1.76.0" data-search-js="search-2b6ce74ff89ae146.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-f2adc0d6ca4d09fb.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-305769736d49e732.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-feafe1bb7466e4bd.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../wayland_client/index.html">wayland_client</a><span class="version">0.31.2</span></h2></div><h2 class="location"><a href="#">Dispatch</a></h2><div class="sidebar-elems"><section><h3><a href="#required-methods">Required Methods</a></h3><ul class="block"><li><a href="#tymethod.event">event</a></li></ul><h3><a href="#provided-methods">Provided Methods</a></h3><ul class="block"><li><a href="#method.event_created_child">event_created_child</a></li></ul><h3><a href="#object-safety">Object Safety</a></h3><h3><a href="#implementors">Implementors</a></h3></section><h2><a href="index.html">In crate wayland_client</a></h2></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../wayland_client/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Trait <a href="index.html">wayland_client</a>::<wbr><a class="trait" href="#">Dispatch</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/wayland_client/event_queue.rs.html#93-131">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub trait Dispatch&lt;I, UserData, State = Self&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.76.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    I: <a class="trait" href="trait.Proxy.html" title="trait wayland_client::Proxy">Proxy</a>,
    State: <a class="trait" href="trait.Dispatch.html" title="trait wayland_client::Dispatch">Dispatch</a>&lt;I, UserData, State&gt;,</div>{
    // Required method
    fn <a href="#tymethod.event" class="fn">event</a>(
        state: <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.reference.html">&amp;mut State</a>,
        proxy: <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.reference.html">&amp;I</a>,
        event: I::<a class="associatedtype" href="trait.Proxy.html#associatedtype.Event" title="type wayland_client::Proxy::Event">Event</a>,
        data: <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.reference.html">&amp;UserData</a>,
        conn: &amp;<a class="struct" href="struct.Connection.html" title="struct wayland_client::Connection">Connection</a>,
        qhandle: &amp;<a class="struct" href="struct.QueueHandle.html" title="struct wayland_client::QueueHandle">QueueHandle</a>&lt;State&gt;
    );

    // Provided method
    fn <a href="#method.event_created_child" class="fn">event_created_child</a>(
        opcode: <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.u16.html">u16</a>,
        _qhandle: &amp;<a class="struct" href="struct.QueueHandle.html" title="struct wayland_client::QueueHandle">QueueHandle</a>&lt;State&gt;
    ) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.76.0/alloc/sync/struct.Arc.html" title="struct alloc::sync::Arc">Arc</a>&lt;dyn <a class="trait" href="backend/trait.ObjectData.html" title="trait wayland_client::backend::ObjectData">ObjectData</a>&gt; { ... }
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A trait for handlers of proxies’ events delivered to an <a href="struct.EventQueue.html" title="struct wayland_client::EventQueue"><code>EventQueue</code></a>.</p>
<h3 id="general-usage"><a href="#general-usage">General usage</a></h3>
<p>You need to implement this trait on your <code>State</code> for every type of Wayland object that will be processed
by the <a href="struct.EventQueue.html" title="struct wayland_client::EventQueue"><code>EventQueue</code></a> working with your <code>State</code>.</p>
<p>You can have different implementations of the trait for the same interface but different <code>UserData</code> type.
This way the events for a given object will be processed by the adequate implementation depending on
which <code>UserData</code> was assigned to it at creation.</p>
<p>The way this trait works is that the <a href="trait.Dispatch.html#tymethod.event" title="associated function wayland_client::Dispatch::event"><code>Dispatch::event()</code></a> method will be invoked by the event queue for
every event received by an object associated to this event queue. Your implementation can then match on
the associated <a href="trait.Proxy.html#associatedtype.Event" title="associated type wayland_client::Proxy::Event"><code>Proxy::Event</code></a> enum and do any processing needed with that event.</p>
<p>In the rare case of an interface with <em>events</em> creating new objects (in the core protocol, the only
instance of this is the <code>wl_data_device.data_offer</code> event), you’ll need to implement the
<a href="trait.Dispatch.html#method.event_created_child" title="associated function wayland_client::Dispatch::event_created_child"><code>Dispatch::event_created_child()</code></a> method. See the <a href="macro.event_created_child.html"><code>event_created_child!</code></a> macro
for a simple way to do this.</p>
<h3 id="modularity"><a href="#modularity">Modularity</a></h3>
<p>To provide generic handlers for downstream usage, it is possible to make an implementation of the trait
that is generic over the last type argument, as illustrated below. Users will then be able to
automatically delegate their implementation to yours using the <a href="macro.delegate_dispatch.html" title="macro wayland_client::delegate_dispatch"><code>delegate_dispatch!</code></a> macro.</p>
<p>As a result, when your implementation is instantiated, the last type parameter <code>State</code> will be the state
struct of the app using your generic implementation. You can put additional trait constraints on it to
specify an interface between your module and downstream code, as illustrated in this example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>wayland_client::{protocol::wl_registry, Dispatch};

<span class="doccomment">/// The type we want to delegate to
</span><span class="kw">struct </span>DelegateToMe;

<span class="doccomment">/// The user data relevant for your implementation.
/// When providing a delegate implementation, it is recommended to use your own type here, even if it is
/// just a unit struct: using () would cause a risk of clashing with another such implementation.
</span><span class="kw">struct </span>MyUserData;

<span class="comment">// Now a generic implementation of Dispatch, we are generic over the last type argument instead of using
// the default State=Self.
</span><span class="kw">impl</span>&lt;State&gt; Dispatch&lt;wl_registry::WlRegistry, MyUserData, State&gt; <span class="kw">for </span>DelegateToMe
<span class="kw">where
    </span><span class="comment">// State is the type which has delegated to this type, so it needs to have an impl of Dispatch itself
    </span>State: Dispatch&lt;wl_registry::WlRegistry, MyUserData&gt;,
    <span class="comment">// If your delegate type has some internal state, it'll need to access it, and you can
    // require it by adding custom trait bounds.
    // In this example, we just require an AsMut implementation
    </span>State: AsMut&lt;DelegateToMe&gt;,
{
    <span class="kw">fn </span>event(
        state: <span class="kw-2">&amp;mut </span>State,
        _proxy: <span class="kw-2">&amp;</span>wl_registry::WlRegistry,
        _event: wl_registry::Event,
        _udata: <span class="kw-2">&amp;</span>MyUserData,
        _conn: <span class="kw-2">&amp;</span>wayland_client::Connection,
        _qhandle: <span class="kw-2">&amp;</span>wayland_client::QueueHandle&lt;State&gt;,
    ) {
        <span class="comment">// Here the delegate may handle incoming events as it pleases.

        // For example, it retrives its state and does some processing with it
        </span><span class="kw">let </span>me: <span class="kw-2">&amp;mut </span>DelegateToMe = state.as_mut();
        <span class="comment">// do something with `me` ...
    </span>}
}</code></pre></div>
<p><strong>Note:</strong> Due to limitations in Rust’s trait resolution algorithm, a type providing a generic
implementation of <a href="trait.Dispatch.html" title="trait wayland_client::Dispatch"><code>Dispatch</code></a> cannot be used directly as the dispatching state, as rustc
currently fails to understand that it also provides <code>Dispatch&lt;I, U, Self&gt;</code> (assuming all other
trait bounds are respected as well).</p>
</div></details><h2 id="required-methods" class="section-header">Required Methods<a href="#required-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="tymethod.event" class="method"><a class="src rightside" href="../src/wayland_client/event_queue.rs.html#110-117">source</a><h4 class="code-header">fn <a href="#tymethod.event" class="fn">event</a>(
    state: <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.reference.html">&amp;mut State</a>,
    proxy: <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.reference.html">&amp;I</a>,
    event: I::<a class="associatedtype" href="trait.Proxy.html#associatedtype.Event" title="type wayland_client::Proxy::Event">Event</a>,
    data: <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.reference.html">&amp;UserData</a>,
    conn: &amp;<a class="struct" href="struct.Connection.html" title="struct wayland_client::Connection">Connection</a>,
    qhandle: &amp;<a class="struct" href="struct.QueueHandle.html" title="struct wayland_client::QueueHandle">QueueHandle</a>&lt;State&gt;
)</h4></section></summary><div class="docblock"><p>Called when an event from the server is processed</p>
<p>This method contains your logic for processing events, which can vary wildly from an object to the
other. You are given as argument:</p>
<ul>
<li>a proxy representing the object that received this event</li>
<li>the event itself as the <a href="trait.Proxy.html#associatedtype.Event" title="associated type wayland_client::Proxy::Event"><code>Proxy::Event</code></a> enum (which you’ll need to match against)</li>
<li>a reference to the <code>UserData</code> that was associated with that object on creation</li>
<li>a reference to the <a href="struct.Connection.html" title="struct wayland_client::Connection"><code>Connection</code></a> in case you need to access it</li>
<li>a reference to a <a href="struct.QueueHandle.html" title="struct wayland_client::QueueHandle"><code>QueueHandle</code></a> associated with the <a href="struct.EventQueue.html" title="struct wayland_client::EventQueue"><code>EventQueue</code></a> currently processing events, in
case you need to create new objects that you want associated to the same <a href="struct.EventQueue.html" title="struct wayland_client::EventQueue"><code>EventQueue</code></a>.</li>
</ul>
</div></details></div><h2 id="provided-methods" class="section-header">Provided Methods<a href="#provided-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="method.event_created_child" class="method"><a class="src rightside" href="../src/wayland_client/event_queue.rs.html#124-130">source</a><h4 class="code-header">fn <a href="#method.event_created_child" class="fn">event_created_child</a>(
    opcode: <a class="primitive" href="https://doc.rust-lang.org/1.76.0/std/primitive.u16.html">u16</a>,
    _qhandle: &amp;<a class="struct" href="struct.QueueHandle.html" title="struct wayland_client::QueueHandle">QueueHandle</a>&lt;State&gt;
) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.76.0/alloc/sync/struct.Arc.html" title="struct alloc::sync::Arc">Arc</a>&lt;dyn <a class="trait" href="backend/trait.ObjectData.html" title="trait wayland_client::backend::ObjectData">ObjectData</a>&gt;</h4></section></summary><div class="docblock"><p>Method used to initialize the user-data of objects created by events</p>
<p>If the interface does not have any such event, you can ignore it. If not, the
<a href="macro.event_created_child.html"><code>event_created_child!</code></a> macro is provided for overriding it.</p>
</div></details></div><h2 id="object-safety" class="section-header">Object Safety<a href="#object-safety" class="anchor">§</a></h2><div class="object-safety-info">This trait is <b>not</b> <a href="https://doc.rust-lang.org/1.76.0/reference/items/traits.html#object-safety">object safe</a>.</div><h2 id="implementors" class="section-header">Implementors<a href="#implementors" class="anchor">§</a></h2><div id="implementors-list"></div><script src="../trait.impl/wayland_client/event_queue/trait.Dispatch.js" async></script></section></div></main></body></html>